#include "packet_encode.h"
#include "protocol.h"
#include <time.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

//****************************************************************************************************
//****************************************************************************************************
//****************************************************************************************************
// DISCLAIMER: THIS FILE WAS AUTO-GENERATED BY template_generator.py
// DO NOT MODIFY THIS FILE DIRECTLY!
// TO MODIFY THE PROTOCOL, EDIT protocol.json AND RE-RUN template_generator.py
//****************************************************************************************************
//****************************************************************************************************
//****************************************************************************************************

int is_command_packet(uint8_t* packet, size_t packet_size) {
	if (packet_size != 7) return -1; // Incorrect size
	if (packet[1] != COMMAND_MSG_ID) return -1; // Incorrect command id
	return packet[3];
}

int get_command_uuid(uint8_t* packet) {
	return packet[4];
}

int generate_ack_packet(uint8_t *packet, size_t packet_size, uint8_t *generated_packet) {
  if (packet_size != 7) {
    return -1;
  }
  if (!verify_packet(packet, packet_size)) {
    return -2;
  }

  int command_id = is_command_packet(packet, packet_size);
  if (command_id < 0 || command_id > 255) {
    return -3;
  }
  uint8_t payload[2];
  payload[0] = command_id; // command id
  payload[1] = get_command_uuid(packet); // command uuid
  int written = generate_packet(payload, 2, generated_packet, COMMAND_ACK_MSG_ID);
  if (written != 7) {
    return -4;
  }
  return 7;
}

size_t generate_command_payload(uint8_t *buffer, uint8_t command_id, uint8_t command_counter) {
	memcpy(buffer, &command_id, sizeof(command_id));	// Byte 1: command id
	memcpy(buffer + sizeof(command_id), &command_counter, sizeof(command_counter)); // byte 2 command counter
	return sizeof(command_id) + sizeof(command_counter);
}

bool extract_command(uint8_t *buffer, uint8_t buffer_size, struct CommandStruct* destination) {
	if (buffer_size != 2) return false;
	destination->command_id = buffer[0];
	destination->command_counter = buffer[1];
	return true;
}

int get_msg_size(int message_id) {
	switch (message_id) {
    	case ROCKETSTATEVECTOR_MSG_ID:
			return ROCKETSTATEVECTOR_SIZE;
    	case ROCKETSERVODEFLECTION_MSG_ID:
			return ROCKETSERVODEFLECTION_SIZE;
    	case ROCKETSTATE_MSG_ID:
			return ROCKETSTATE_SIZE;
    	case ROCKETGROUNDEKF_MSG_ID:
			return ROCKETGROUNDEKF_SIZE;
    	case ROCKETSENSORDATA_MSG_ID:
			return ROCKETSENSORDATA_SIZE;
    	case ROCKETANALOGFEEDBACKDATA_MSG_ID:
			return ROCKETANALOGFEEDBACKDATA_SIZE;
    	default:
			return -1;
	}
}

bool is_data_send_msg(int message_id) {
	return (message_id >= 10) && (message_id <= 10 + 6);
}

#ifdef INCLUDE_PROTOCOL_SQL_MACROS
	
    bool convert_data_msg_to_sql_cmd(int message_id, uint8_t *data, size_t data_size, char *sql_cmd) {
		if (!is_data_send_msg(message_id)) {
			return false;
		}

		switch (message_id) {
    	    case ROCKETSTATEVECTOR_MSG_ID: {
        if (data_size != ROCKETSTATEVECTOR_SIZE) {
          printf("warning: wrong data size!\n");
        }
				struct RocketStateVector cvt_data;
				RocketStateVector_decode(data, &cvt_data);
				ROCKETSTATEVECTOR_SQL_ADD_ENTRY(sql_cmd, &cvt_data);
				return true;
			} 
    	    case ROCKETSERVODEFLECTION_MSG_ID: {
        if (data_size != ROCKETSERVODEFLECTION_SIZE) {
          printf("warning: wrong data size!\n");
        }
				struct RocketServoDeflection cvt_data;
				RocketServoDeflection_decode(data, &cvt_data);
				ROCKETSERVODEFLECTION_SQL_ADD_ENTRY(sql_cmd, &cvt_data);
				return true;
			} 
    	    case ROCKETSTATE_MSG_ID: {
        if (data_size != ROCKETSTATE_SIZE) {
          printf("warning: wrong data size!\n");
        }
				struct RocketState cvt_data;
				RocketState_decode(data, &cvt_data);
				ROCKETSTATE_SQL_ADD_ENTRY(sql_cmd, &cvt_data);
				return true;
			} 
    	    case ROCKETGROUNDEKF_MSG_ID: {
        if (data_size != ROCKETGROUNDEKF_SIZE) {
          printf("warning: wrong data size!\n");
        }
				struct RocketGroundEKF cvt_data;
				RocketGroundEKF_decode(data, &cvt_data);
				ROCKETGROUNDEKF_SQL_ADD_ENTRY(sql_cmd, &cvt_data);
				return true;
			} 
    	    case ROCKETSENSORDATA_MSG_ID: {
        if (data_size != ROCKETSENSORDATA_SIZE) {
          printf("warning: wrong data size!\n");
        }
				struct RocketSensorData cvt_data;
				RocketSensorData_decode(data, &cvt_data);
				ROCKETSENSORDATA_SQL_ADD_ENTRY(sql_cmd, &cvt_data);
				return true;
			} 
    	    case ROCKETANALOGFEEDBACKDATA_MSG_ID: {
        if (data_size != ROCKETANALOGFEEDBACKDATA_SIZE) {
          printf("warning: wrong data size!\n");
        }
				struct RocketAnalogFeedbackData cvt_data;
				RocketAnalogFeedbackData_decode(data, &cvt_data);
				ROCKETANALOGFEEDBACKDATA_SQL_ADD_ENTRY(sql_cmd, &cvt_data);
				return true;
			} 
    		default:
				return false;
		}
	}

#endif


void RocketStateVector_encode(struct RocketStateVector *input, uint8_t *output) {
		memcpy(output + 0, &input->velocity_x, 4);
		memcpy(output + 4, &input->velocity_y, 4);
		memcpy(output + 8, &input->velocity_z, 4);
		memcpy(output + 12, &input->attitude_w, 4);
		memcpy(output + 16, &input->attitude_x, 4);
		memcpy(output + 20, &input->attitude_y, 4);
		memcpy(output + 24, &input->attitude_z, 4);
		memcpy(output + 28, &input->position_x, 4);
		memcpy(output + 32, &input->position_y, 4);
		memcpy(output + 36, &input->position_z, 4);
		memcpy(output + 40, &input->world_x, 4);
		memcpy(output + 44, &input->world_y, 4);
		memcpy(output + 48, &input->world_z, 4);
		memcpy(output + 52, &input->timestamp, 8);

}

void RocketStateVector_decode(uint8_t *input, struct RocketStateVector *output) {
		memcpy(&output->velocity_x, input + 0, 4);
		memcpy(&output->velocity_y, input + 4, 4);
		memcpy(&output->velocity_z, input + 8, 4);
		memcpy(&output->attitude_w, input + 12, 4);
		memcpy(&output->attitude_x, input + 16, 4);
		memcpy(&output->attitude_y, input + 20, 4);
		memcpy(&output->attitude_z, input + 24, 4);
		memcpy(&output->position_x, input + 28, 4);
		memcpy(&output->position_y, input + 32, 4);
		memcpy(&output->position_z, input + 36, 4);
		memcpy(&output->world_x, input + 40, 4);
		memcpy(&output->world_y, input + 44, 4);
		memcpy(&output->world_z, input + 48, 4);
		memcpy(&output->timestamp, input + 52, 8);

}


void RocketServoDeflection_encode(struct RocketServoDeflection *input, uint8_t *output) {
		memcpy(output + 0, &input->servo_deflection_1, 4);
		memcpy(output + 4, &input->servo_deflection_2, 4);
		memcpy(output + 8, &input->servo_deflection_3, 4);
		memcpy(output + 12, &input->servo_deflection_4, 4);
		memcpy(output + 16, &input->timestamp, 8);

}

void RocketServoDeflection_decode(uint8_t *input, struct RocketServoDeflection *output) {
		memcpy(&output->servo_deflection_1, input + 0, 4);
		memcpy(&output->servo_deflection_2, input + 4, 4);
		memcpy(&output->servo_deflection_3, input + 8, 4);
		memcpy(&output->servo_deflection_4, input + 12, 4);
		memcpy(&output->timestamp, input + 16, 8);

}


void RocketState_encode(struct RocketState *input, uint8_t *output) {
		memcpy(output + 0, &input->rocket_state, 1);
		memcpy(output + 1, &input->firing_channel_1, 1);
		memcpy(output + 2, &input->firing_channel_2, 1);
		memcpy(output + 3, &input->firing_channel_3, 1);
		memcpy(output + 4, &input->timestamp, 8);

}

void RocketState_decode(uint8_t *input, struct RocketState *output) {
		memcpy(&output->rocket_state, input + 0, 1);
		memcpy(&output->firing_channel_1, input + 1, 1);
		memcpy(&output->firing_channel_2, input + 2, 1);
		memcpy(&output->firing_channel_3, input + 3, 1);
		memcpy(&output->timestamp, input + 4, 8);

}


void RocketGroundEKF_encode(struct RocketGroundEKF *input, uint8_t *output) {
		memcpy(output + 0, &input->pn_matrix_d1, 4);
		memcpy(output + 4, &input->pn_matrix_d2, 4);
		memcpy(output + 8, &input->pn_matrix_d3, 4);
		memcpy(output + 12, &input->pn_matrix_d4, 4);
		memcpy(output + 16, &input->pn_matrix_d5, 4);
		memcpy(output + 20, &input->pn_matrix_d6, 4);
		memcpy(output + 24, &input->timestamp, 8);

}

void RocketGroundEKF_decode(uint8_t *input, struct RocketGroundEKF *output) {
		memcpy(&output->pn_matrix_d1, input + 0, 4);
		memcpy(&output->pn_matrix_d2, input + 4, 4);
		memcpy(&output->pn_matrix_d3, input + 8, 4);
		memcpy(&output->pn_matrix_d4, input + 12, 4);
		memcpy(&output->pn_matrix_d5, input + 16, 4);
		memcpy(&output->pn_matrix_d6, input + 20, 4);
		memcpy(&output->timestamp, input + 24, 8);

}


void RocketSensorData_encode(struct RocketSensorData *input, uint8_t *output) {
		memcpy(output + 0, &input->accelerometer_x, 4);
		memcpy(output + 4, &input->accelerometer_y, 4);
		memcpy(output + 8, &input->accelerometer_z, 4);
		memcpy(output + 12, &input->gyro_x, 4);
		memcpy(output + 16, &input->gyro_y, 4);
		memcpy(output + 20, &input->gyro_z, 4);
		memcpy(output + 24, &input->gps_x, 4);
		memcpy(output + 28, &input->gps_y, 4);
		memcpy(output + 32, &input->gps_z, 4);
		memcpy(output + 36, &input->timestamp, 8);

}

void RocketSensorData_decode(uint8_t *input, struct RocketSensorData *output) {
		memcpy(&output->accelerometer_x, input + 0, 4);
		memcpy(&output->accelerometer_y, input + 4, 4);
		memcpy(&output->accelerometer_z, input + 8, 4);
		memcpy(&output->gyro_x, input + 12, 4);
		memcpy(&output->gyro_y, input + 16, 4);
		memcpy(&output->gyro_z, input + 20, 4);
		memcpy(&output->gps_x, input + 24, 4);
		memcpy(&output->gps_y, input + 28, 4);
		memcpy(&output->gps_z, input + 32, 4);
		memcpy(&output->timestamp, input + 36, 8);

}


void RocketAnalogFeedbackData_encode(struct RocketAnalogFeedbackData *input, uint8_t *output) {
		memcpy(output + 0, &input->current_fb_33, 2);
		memcpy(output + 2, &input->pyro_0_cont, 2);
		memcpy(output + 4, &input->pyro_1_cont, 2);
		memcpy(output + 6, &input->pyro_2_cont, 2);
		memcpy(output + 8, &input->pyro_channel_deploy, 1);
		memcpy(output + 9, &input->timestamp, 8);

}

void RocketAnalogFeedbackData_decode(uint8_t *input, struct RocketAnalogFeedbackData *output) {
		memcpy(&output->current_fb_33, input + 0, 2);
		memcpy(&output->pyro_0_cont, input + 2, 2);
		memcpy(&output->pyro_1_cont, input + 4, 2);
		memcpy(&output->pyro_2_cont, input + 6, 2);
		memcpy(&output->pyro_channel_deploy, input + 8, 1);
		memcpy(&output->timestamp, input + 9, 8);

}